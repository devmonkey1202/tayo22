// copy_to_neon_upserts.js
// 목적: PostgreSQL COPY 덤프(tayodrive_backup.sql)를 현재 스키마에 맞는
// INSERT ... ON CONFLICT 업서트 SQL로 변환. (윈도우 CMD/Prisma 호환)
// 원칙: 가짜값/보정 없음. 원본 데이터만 이관. \N -> NULL, \n/\t 등 이스케이프 복원.

const fs = require('fs');

if (process.argv.length < 4) {
  console.error('Usage: node copy_to_neon_upserts.js <input_dump.sql> <output.sql>');
  process.exit(1);
}

const inPath = process.argv[2];
const outPath = process.argv[3];
const raw = fs.readFileSync(inPath, 'utf8');

// COPY 블록 추출
function extractCopy(table) {
  const re = new RegExp(
    String.raw`COPY\s+public\."${table}"\s*\(\s*([^)]+)\s*\)\s*FROM\s+stdin;([\s\S]*?)\\\.\s*\n`,
    'i'
  );
  const m = raw.match(re);
  if (!m) return null;
  const cols = m[1].split(',').map(s => s.trim().replace(/^"|"$/g,''));
  const body = m[2];
  const lines = body.split('\n').filter(l => l.length > 0);
  const rows = [];
  for (const line of lines) {
    // COPY 텍스트는 탭 구분, NULL은 \N, 특수문자는 \n, \t, \\ 로 이스케이프됨.
    const fields = line.split('\t').map(f => f);
    if (fields.length === 1 && fields[0] === '\\.') break;
    rows.push(fields);
  }
  return { cols, rows };
}

function unescapeCopyText(s) {
  // \N -> null
  if (s === '\\N') return null;
  // 역슬래시 이스케이프 복원
  // 순서 중요: \\ -> \  먼저 처리
  let r = s.replace(/\\\\/g, '\\');
  r = r.replace(/\\t/g, '\t').replace(/\\r/g, '\r').replace(/\\n/g, '\n');
  return r;
}

function sqlString(v) {
  if (v === null || v === undefined) return 'NULL';
  if (typeof v === 'number') return String(v);
  if (/^-?\d+(\.\d+)?$/.test(v)) return v; // 숫자 문자열
  if (/^(true|false)$/i.test(v)) return v.toLowerCase();
  // 문자열 리터럴 안전 이스케이프
  let s = String(v).replace(/'/g, "''");
  // 실제 개행/탭 포함 가능 → E'' 리터럴 사용
  return "E'" + s.replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/\t/g, '\\t').replace(/\r/g, '\\r') + "'";
}

function buildUpserts(table, colOrder, rows, conflictCols, targetCols, mapFn) {
  if (!rows.length) return '';
  const chunks = [];
  const batchSize = 500; // 안전 배치
  for (let i=0;i<rows.length;i+=batchSize) {
    const part = rows.slice(i, i+batchSize);
    const valuesSql = part.map(rawRow => {
      const obj = {};
      colOrder.forEach((c, idx) => obj[c] = unescapeCopyText(rawRow[idx]));
      const mapped = mapFn(obj);
      const vals = targetCols.map(c => sqlString(mapped[c]));
      return '(' + vals.join(', ') + ')';
    }).join(',\n');

    const setClause = targetCols
      .filter(c => !conflictCols.includes(c))
      .map(c => `"${c}" = EXCLUDED."${c}"`)
      .join(', ');

    const insertSql =
      `INSERT INTO "${table}" (${targetCols.map(c=>`"${c}"`).join(', ')})\n` +
      `VALUES\n${valuesSql}\n` +
      `ON CONFLICT (${conflictCols.map(c=>`"${c}"`).join(', ')}) DO UPDATE SET ${setClause};\n`;
    chunks.push(insertSql);
  }
  return chunks.join('\n');
}

let sql = '';
sql += '-- Generated by copy_to_neon_upserts.js\n';
sql += 'BEGIN;\n';

// 1) Reservation
const c1 = extractCopy('Reservation');
if (c1) {
  // COPY 열: id, name, phone, gender, carType, region, memo, createdAt, status (덤프 기준 - 확실)
  // 타겟 열: 동일 (스키마 일치)
  const targetCols = ['id','name','phone','gender','carType','region','memo','createdAt','status'];
  const up1 = buildUpserts(
    'Reservation',
    c1.cols,
    c1.rows,
    ['id'], // PK
    targetCols,
    (o) => ({
      id: o.id,
      name: o.name,
      phone: o.phone,
      gender: o.gender,
      carType: o.carType,
      region: o.region,
      memo: o.memo,
      createdAt: o.createdAt,
      status: o.status
    })
  );
  sql += up1;
  sql += `SELECT setval('public."Reservation_id_seq"', (SELECT COALESCE(MAX("id"),1) FROM "Reservation"), true);\n`;
}

// 2) Review
const c2 = extractCopy('Review');
if (c2) {
  // COPY 열: id, rating, title, body, author, email, image, createdAt, updatedAt, views (확실)
  const targetCols = ['id','rating','title','body','author','email','image','createdAt','updatedAt','views'];
  const up2 = buildUpserts(
    'Review',
    c2.cols,
    c2.rows,
    ['id'],
    targetCols,
    (o)=>({
      id:o.id, rating:o.rating, title:o.title, body:o.body,
      author:o.author, email:o.email, image:o.image,
      createdAt:o.createdAt, updatedAt:o.updatedAt, views:o.views
    })
  );
  sql += up2;
  sql += `SELECT setval('public."Review_id_seq"', (SELECT COALESCE(MAX("id"),1) FROM "Review"), true);\n`;
}

// 3) Recipient
const c3 = extractCopy('Recipient');
if (c3) {
  // COPY 열: id, phone, label, createdAt, name (확실)
  // 타겟: id, name, label, phone, createdAt (열 순서만 다름)
  const targetCols = ['id','name','label','phone','createdAt'];
  const up3 = buildUpserts(
    'Recipient',
    c3.cols,
    c3.rows,
    ['id'],
    targetCols,
    (o)=>({
      id:o.id, name:o.name, label:o.label, phone:o.phone, createdAt:o.createdAt
    })
  );
  sql += up3;
  sql += `SELECT setval('public."Recipient_id_seq"', (SELECT COALESCE(MAX("id"),1) FROM "Recipient"), true);\n`;
}

// 4) Faq (비어있을 수 있음)
const c4 = extractCopy('Faq');
if (c4) {
  const targetCols = ['id','icon','q','a'];
  const up4 = buildUpserts(
    'Faq',
    c4.cols,
    c4.rows,
    ['id'],
    targetCols,
    (o)=>({ id:o.id, icon:o.icon, q:o.q, a:o.a })
  );
  sql += up4;
  sql += `SELECT setval('public."Faq_id_seq"', (SELECT COALESCE(MAX("id"),1) FROM "Faq"), true);\n`;
}

// 5) Setting
const c5 = extractCopy('Setting');
if (c5) {
  const targetCols = ['id','kakaoUrl','metaTitle','metaDesc'];
  const up5 = buildUpserts(
    'Setting',
    c5.cols,
    c5.rows,
    ['id'],
    targetCols,
    (o)=>({ id:o.id, kakaoUrl:o.kakaoUrl, metaTitle:o.metaTitle, metaDesc:o.metaDesc })
  );
  sql += up5;
  sql += `SELECT setval('public."Setting_id_seq"', (SELECT COALESCE(MAX("id"),1) FROM "Setting"), true);\n`;
}

// (선택) 덤프에 있던 보조 인덱스 중 스키마에 없는 것 보강
sql += `CREATE INDEX IF NOT EXISTS idx_reservation_created_at ON "Reservation" ("createdAt");\n`;

sql += 'COMMIT;\n';

fs.writeFileSync(outPath, sql, 'utf8');
console.log('DONE. wrote', outPath);
